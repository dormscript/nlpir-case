需要具备的知识点闭包闭包和匿名函数在PHP5.3.0中引入的。闭包是指：创建时封装周围状态的函数。即使闭包所处的环境不存在了，闭包中封装的状态依然存在。理论上，闭包和匿名函数是不同的概念。但是PHP将其视作相同概念。实际上，闭包和匿名函数是伪装成函数的对象。他们是Closure类的实例。闭包和字符串、整数一样，是一等值类型。创建闭包：&lt;?php$closure=function($name){return'Hello'.$name;};echo$closure('nesfo');//Hellonesfovar_dump(method_exists($closure,'__invoke'));//true我们之所以能调用$closure变量，是因为这个变量的值是一个闭包，而且闭包对象实现了__invoke()魔术方法。只要变量名后有(),PHP就会查找并调用__invoke()方法。通常会把PHP闭包当作函数的回调使用。array_map(),preg_replace_callback()方法都会用到回调函数，这是使用闭包的最佳时机！举个例子：&lt;?php$numbersPlusOne=array_map(function($number){return$number+1;},[1,2,3]);print_r($numbersPlusOne);得到结果：[2,3,4]在闭包出现之前，只能单独创建具名函数，然后使用名称引用那个函数。这么做，代码执行会稍微慢点，而且把回调的实现和使用场景隔离了。&lt;?phpfunctionincrementNum($number){return$number+1;}$numbersPlusOne=array_map('incrementNum',[1,2,3]);print_r($numbersPlusOne);SPLArrayAccess实现ArrayAccess接口，可以使得object像array那样操作。ArrayAccess接口包含四个必须实现的方法：interfaceArrayAccess{//检查一个偏移位置是否存在publicmixedoffsetExists(mixed$offset);//获取一个偏移位置的值publicmixedoffsetGet(mixed$offset);//设置一个偏移位置的值publicmixedoffsetSet(mixed$offset);//复位一个偏移位置的值publicmixedoffsetUnset(mixed$offset);}SplObjectStorageSplObjectStorage类实现了以对象为键的映射（map）或对象的集合（如果忽略作为键的对象所对应的数据）这种数据结构。这个类的实例很像一个数组，但是它所存放的对象都是唯一。该类的另一个特点是，可以直接从中删除指定的对象，而不需要遍历或搜索整个集合。::class语法因为::class表示是字符串。用::class的好处在于IDE里面可以直接改名一个class，然后IDE自动处理相关引用。同时，PHP执行相关代码时，是不会先加载相关class的。同理，代码自动化检查inspect也可以正确识别class。Pimple容器流程浅析Pimpl是php社区中比较流行的容器。代码不是很多，详见https://github.com/silexphp/P...。我们的应用可以基于Pimple开发：namespaceEasyWeChat\Foundation;usePimple\Container;classApplicationextendsContainer{/***ServiceProviders.**@vararray*/protected$providers=[ServiceProviders\ServerServiceProvider::class,ServiceProviders\UserServiceProvider::class];/***Applicationconstructor.**@paramarray$config*/publicfunction__construct($config){parent::__construct();$this['config']=function()use($config){returnnewConfig($config);};if($this['config']['debug']){error_reporting(E_ALL);}$this-&gt;registerProviders();}/***Addaprovider.**@paramstring$provider**@returnApplication*/publicfunctionaddProvider($provider){array_push($this-&gt;providers,$provider);return$this;}/***Setproviders.**@paramarray$providers*/publicfunctionsetProviders(array$providers){$this-&gt;providers=[];foreach($providersas$provider){$this-&gt;addProvider($provider);}}/***Returnallproviders.**@returnarray*/publicfunctiongetProviders(){return$this-&gt;providers;}/***Magicgetaccess.**@paramstring$id**@returnmixed*/publicfunction__get($id){return$this-&gt;offsetGet($id);}/***Magicsetaccess.**@paramstring$id*@parammixed$value*/publicfunction__set($id,$value){$this-&gt;offsetSet($id,$value);}}如何使用我们的应用：$app=newApplication([]);$user=$app-&gt;user;之后我们就可以使用$user对象的方法了。我们发现其实并没有$this-&gt;user这个属性，但是可以直接使用。主要是这两个方法起的作用：publicfunctionoffsetSet($id,$value){}publicfunctionoffsetGet($id){}下面我们将解释在执行这两句代码，Pimple做了什么。但在解释这个之前，我们先看看容器的一些核心概念。服务提供者服务提供者是连接容器与具体功能实现类的桥梁。服务提供者需要实现接口ServiceProviderInterface:namespacePimple;/***Pimpleserviceproviderinterface.**@authorFabienPotencier*@authorDominikZogg*/interfaceServiceProviderInterface{/***Registersservicesonthegivencontainer.**Thismethodshouldonlybeusedtoconfigureservicesandparameters.*Itshouldnotgetservices.**@paramContainer$pimpleAcontainerinstance*/publicfunctionregister(Container$pimple);}所有服务提供者必须实现接口register方法。我们的应用里默认有2个服务提供者：protected$providers=[ServiceProviders\ServerServiceProvider::class,ServiceProviders\UserServiceProvider::class];以UserServiceProvider为例，我们看其代码实现：namespaceEasyWeChat\Foundation\ServiceProviders;useEasyWeChat\User\User;usePimple\Container;usePimple\ServiceProviderInterface;/***ClassUserServiceProvider.*/classUserServiceProviderimplementsServiceProviderInterface{/***Registersservicesonthegivencontainer.**Thismethodshouldonlybeusedtoconfigureservicesandparameters.*Itshouldnotgetservices.**@paramContainer$pimpleAcontainerinstance*/publicfunctionregister(Container$pimple){$pimple['user']=function($pimple){returnnewUser($pimple['access_token']);};}}我们看到，该服务提供者的注册方法会给容器增加属性user，但是返回的不是对象，而是一个闭包。这个后面我再做讲解。服务注册我们在Application里构造函数里使用$this-&gt;registerProviders();对所有服务提供者进行了注册：privatefunctionregisterProviders(){foreach($this-&gt;providersas$provider){$this-&gt;register(new$provider());}}仔细看，我们发现这里实例化了服务提供者，并调用了容器Pimple的register方法：publicfunctionregister(ServiceProviderInterface$provider,array$values=array()){$provider-&gt;register($this);foreach($valuesas$key=&gt;$value){$this[$key]=$value;}return$this;}而这里调用了服务提供者的register方法，也就是我们在上一节中提到的：注册方法给容器增加了属性user，但返回的不是对象，而是一个闭包。当我们给容器Pimple添加属性user的同时，会调用offsetSet($id,$value)方法：给容器Pimple的属性values、keys分别赋值：$this-&gt;values[$id]=$value;$this-&gt;keys[$id]=true;到这里，我们还没有实例化真正提供实际功能的类EasyWeChat\User\Usr。但已经完成了服务提供者的注册工作。当我们运行到这里：$user=$app-&gt;user;会调用offsetGet($id)并进行实例化真正的类：$raw=$this-&gt;values[$id];$val=$this-&gt;values[$id]=$raw($this);$this-&gt;raw[$id]=$raw;$this-&gt;frozen[$id]=true;return$val;$raw获取的是闭包：$pimple['user']=function($pimple){returnnewUser($pimple['access_token']);};$raw($this)返回的是实例化的对象User。也就是说只有实际调用才会去实例化具体的类。后面我们就可以通过$this['user']或者$this-&gt;user调用User类里的方法了。当然，Pimple里还有很多特性值得我们去深入研究，这里不做过多讲解。参考1、PHP:数组式访问-Manualhttp://php.net/manual/zh/clas...2、利用SPL快速实现Observer设计模式https://www.ibm.com/developer...3、Pimple-AsimplePHPDependencyInjectionContainerhttps://pimple.sensiolabs.org/4、Laravel源码里面为什么要用::class语法？-知乎https://www.zhihu.com/questio...5、Laravel学习笔记——神奇的服务容器|LaravelChina社区-高品质的Laravel和PHP开发者社区-PoweredbyPHPHubhttps://laravel-china.org/top...6、Pimple/README_zh.rstatmaster·52fhy/Pimplehttps://github.com/52fhy/Pimp...原文发布于博客园：http://www.cnblogs.com/52fhy/...
